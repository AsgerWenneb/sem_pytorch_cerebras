const sparse = @import_module("sparse.csl");

// Square kernel dimensions
// param kernel_dim: i16;

// PE rectangle dimensions 
param N_kernel: u16;
param M_kernel: u16;

param N_per_PE: u16;
param max_nz_per_n: u16;


// This example uses kernel_x_dim x kernel_y_dim PEs
const memcpy = @import_module("<memcpy/get_params>", .{
    .width = M_kernel,
    .height = N_kernel
});

const color_a: color = @get_color(0);
const color_b: color = @get_color(1);

layout {
    // PE coordinates are (column, row)
    @set_rectangle(M_kernel, N_kernel);

	for (@range(u16, N_kernel)) |pe_y| {
		for (@range(u16, M_kernel)) |pe_x| {
			var send_color: color = color_a;
			var recv_color: color = color_b;

			if (pe_x % 2 == 1) {
				send_color = color_b;
				recv_color = color_a;
			}

			@set_tile_code(pe_x, pe_y, "pe_program.csl", 
				.{
					.memcpy_params = memcpy.get_params(pe_x),
					.N_per_PE = N_per_PE,
					.NZ_per_N = max_nz_per_n,
					.M_kernel = M_kernel,
					.send_color = send_color,
					.recv_color = recv_color
				});

			@set_color_config(pe_x, pe_y, send_color, .{.routes = .{ .rx = .{RAMP}, .tx = .{EAST} }});
			@set_color_config(pe_x, pe_y, recv_color, .{.routes = .{ .rx = .{WEST}, .tx = .{RAMP} }});
		}
	}

    // export symbol names
    @export_name("NZ", [*]u32, true);
    @export_name("A", [*]sparse.triplet, true);
    @export_name("x", [*]f32, true);
    @export_name("y", [*]f32, true);
    @export_name("compute", fn()void);
}
