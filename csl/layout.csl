const sparse = @import_module("sparse.csl");

// Square kernel dimensions
// param kernel_dim: i16;

// PE rectangle dimensions 
param N_kernel: u16;
param M_kernel: u16;

param N_per_PE: u16;
param max_nz_per_n: u16;


// This example uses kernel_x_dim x kernel_y_dim PEs
const memcpy = @import_module("<memcpy/get_params>", .{
    .width = M_kernel,
    .height = N_kernel
});

const color_0: color = @get_color(0);
const color_1: color = @get_color(1);

layout {
    // PE coordinates are (column, row)
    @set_rectangle(M_kernel, N_kernel);

	for (@range(u16, N_kernel)) |pe_y| {
		for (@range(u16, M_kernel)) |pe_x| {
			var color_a: color = color_0;
			var color_b: color = color_1;

			if (pe_x % 2 == 1) {
				color_a = color_1;
				color_b = color_0;
			}

			var recv_color: color = color_a;
			var send_recv_color: color = color_b;

			// Swap colors if right of / above diagonal
			if (pe_x > pe_y) {
				recv_color = color_b;
				send_recv_color = color_a;
			}

			@set_tile_code(pe_x, pe_y, "pe_program.csl", 
				.{
					.memcpy_params = memcpy.get_params(pe_x),
					.N_per_PE = N_per_PE,
					.NZ_per_N = max_nz_per_n,
					.M_kernel = M_kernel,
					.recv_color = recv_color,
					.send_recv_color = send_recv_color
				});

			if (pe_x == pe_y) { // Diagonal
				@set_color_config(pe_x, pe_y, color_a, .{.routes = .{ .rx = .{WEST}, .tx = .{RAMP} }});
				@set_color_config(pe_x, pe_y, color_b, .{.routes = .{ .rx = .{EAST}, .tx = .{RAMP} }});
			} else if (pe_x < pe_y) { // Left of / Below diagonal
				@set_color_config(pe_x, pe_y, color_a, .{.routes = .{ .rx = .{WEST}, .tx = .{RAMP} }});
				@set_color_config(pe_x, pe_y, color_b, .{.routes = .{ .rx = .{RAMP}, .tx = .{EAST} }});
			} else { // Right of / above diagonal
				@set_color_config(pe_x, pe_y, color_a, .{.routes = .{ .rx = .{RAMP}, .tx = .{WEST} }});
				@set_color_config(pe_x, pe_y, color_b, .{.routes = .{ .rx = .{EAST}, .tx = .{RAMP} }});
			}
		}
	}

    // export symbol names
    @export_name("NZ", [*]u32, true);
    @export_name("A", [*]sparse.triplet, true);
    @export_name("x", [*]f32, true);
    @export_name("y", [*]f32, true);
    @export_name("compute", fn()void);
}
