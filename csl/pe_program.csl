// Struct containing parameters for memcpy layout
param memcpy_params: comptime_struct;
param N_per_PE: u16;
param NZ_per_N: u16;

const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);
const sparse = @import_module("sparse.csl");

// 48 kB of global memory contain A, x, b, y
var NZ: [1]u32;
var A: [N_per_PE*NZ_per_N]sparse.triplet; // A is stored column major
var x: [N_per_PE]f32;
var y: [N_per_PE]f32;

// ptrs to A, x, b, y will be advertised as symbols to host
var NZ_ptr: [*]u32 = &NZ;
var A_ptr: [*]sparse.triplet = &A;
var x_ptr: [*]f32 = &x;
var y_ptr: [*]f32 = &y;

var triplet: sparse.triplet;

fn compute() void {
	for (@range(u32, NZ[0])) |i| {
		triplet = A[i];

		y[triplet.i] += triplet.x * x[triplet.j];
	}

    sys_mod.unblock_cmd_stream();
}

comptime {
    // Export symbol pointing to y so it is host-readable
    @export_symbol(NZ_ptr, "NZ");
    @export_symbol(A_ptr, "A");
    @export_symbol(x_ptr, "x");
    @export_symbol(y_ptr, "y");

    // Export function so it is host-callable by RPC mechanism
    @export_symbol(compute);
}
