// Struct containing parameters for memcpy layout
param memcpy_params: comptime_struct;
param N_per_PE: u16;
param NZ_per_N: u16;
param M_kernel: u16;

// Colors
param recv_color: color; // Color used to send/recv data between PEs
param send_recv_color: color; // Color used to send/recv data between PEs

// Queue IDs
const send_1_oq = @get_output_queue(2);
const recv_1_iq = @get_input_queue(2);
const recv_2_iq = @get_input_queue(3);

const exit_task_id: local_task_id = @get_local_task_id(9);

const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);
const layout_mod = @import_module("<layout>");
const timestamp = @import_module("<time>");
const sparse = @import_module("sparse.csl");

fn is_left_col() bool {
  return (layout_mod.get_x_coord() == 0);
}

fn is_right_col() bool {
  return (layout_mod.get_x_coord() == M_kernel-1);
}

fn is_diagonal() bool {
  return (layout_mod.get_x_coord() == layout_mod.get_y_coord());
}

// 48 kB of global memory contain A, x, b, y
var NZ: [1]u32;
var A: [N_per_PE*NZ_per_N]sparse.triplet; // A is stored column major
var x: [N_per_PE]f32;
var b: [N_per_PE]f32;
var y: [N_per_PE]f32;

var y_dsd = @get_dsd(mem1d_dsd, .{ .base_address = &y, .extent = N_per_PE });

// ptrs to A, x, b, y will be advertised as symbols to host
var NZ_ptr: [*]u32 = &NZ;
var A_ptr: [*]sparse.triplet = &A;
var x_ptr: [*]f32 = &x;
var b_ptr: [*]f32 = &b;
var y_ptr: [*]f32 = &y;

var triplet: sparse.triplet;

var tscStartBuffer = @zeros([timestamp.tsc_size_words]u16);
var tscEndBuffer = @zeros([timestamp.tsc_size_words]u16);
var start_time = @zeros([timestamp.tsc_size_words]u32);
var end_time = @zeros([timestamp.tsc_size_words]u32);
var start_time_ptr: [*]u32 = &start_time;
var end_time_ptr: [*]u32 = &end_time;

fn gemv() void {
	for (@range(u32, N_per_PE)) |i| {
		y[i] = b[i];
	}

	for (@range(u32, NZ[0])) |i| {
		triplet = A[i];
		y[triplet.i] += triplet.x * x[triplet.j];
	}
}

fn send() void {
    const out_dsd = @get_dsd(fabout_dsd, .{
                      .fabric_color = send_recv_color, .extent = N_per_PE,
                      .output_queue = send_1_oq
                    });

    // After fmovs is done, activate exit_task to unblock cmd_stream
    @fmovs(out_dsd, y_dsd, .{ .async = true, .activate = exit_task_id });
}

fn add_and_send() void {
    const in_dsd = @get_dsd(fabin_dsd, .{
                   .fabric_color = recv_color, .extent = N_per_PE,
                   .input_queue = recv_1_iq
                 });

    const out_dsd = @get_dsd(fabout_dsd, .{
                      .fabric_color = send_recv_color, .extent = N_per_PE,
                      .output_queue = send_1_oq
                    });

    // After fmovs is done, activate exit_task to unblock cmd_stream
    @fadds(out_dsd, y_dsd, in_dsd, .{ .async = true, .activate = exit_task_id });
}

fn recv() void {
	const in_a_dsd = @get_dsd(fabin_dsd, .{
			.fabric_color = recv_color, .extent = N_per_PE,
			.input_queue = recv_1_iq
			});

	// After fadds is done, activate exit_task to unblock cmd stream
	@fadds(y_dsd, y_dsd, in_a_dsd, .{ .async = false });

	const in_b_dsd = @get_dsd(fabin_dsd, .{
				   .fabric_color = send_recv_color, .extent = N_per_PE,
				   .input_queue = recv_2_iq
				 });

	// After fadds is done, activate exit_task to unblock cmd stream
	@fadds(y_dsd, y_dsd, in_b_dsd, .{ .async = true, .activate = exit_task_id });
}

fn recv_top_left() void {
	const in_dsd = @get_dsd(fabin_dsd, .{
				   .fabric_color = send_recv_color, .extent = N_per_PE,
				   .input_queue = recv_2_iq
				 });

	// After fadds is done, activate exit_task to unblock cmd stream
	@fadds(y_dsd, y_dsd, in_dsd, .{ .async = true, .activate = exit_task_id });
}

fn recv_bottom_right() void {
	const in_dsd = @get_dsd(fabin_dsd, .{
				   .fabric_color = recv_color, .extent = N_per_PE,
				   .input_queue = recv_1_iq
				 });

	// After fadds is done, activate exit_task to unblock cmd stream
	@fadds(y_dsd, y_dsd, in_dsd, .{ .async = true, .activate = exit_task_id });
}

fn compute() void {
	timestamp.enable_tsc();
	timestamp.get_timestamp(&tscStartBuffer);

	gemv();

	if (is_diagonal()) {
		if (is_left_col()) {
			recv_top_left();
		} else if (is_right_col()) {
			recv_bottom_right();
		} else {
			recv();
		}
	} else if (is_left_col() or is_right_col()) {
		send();
	} else  {
		add_and_send();
	} 

}

task exit_task() void {
	timestamp.get_timestamp(&tscEndBuffer);
	start_time[0] = @as(u32, tscStartBuffer[0]);
	start_time[1] = @as(u32, tscStartBuffer[1]);
	start_time[2] = @as(u32, tscStartBuffer[2]);
	end_time[0] = @as(u32, tscEndBuffer[0]);
	end_time[1] = @as(u32, tscEndBuffer[1]);
	end_time[2] = @as(u32, tscEndBuffer[2]);
	sys_mod.unblock_cmd_stream();
}

comptime {
    @bind_local_task(exit_task, exit_task_id);

    if (@is_arch("wse3")) {
      @initialize_queue(send_1_oq, .{ .color = send_recv_color });
      @initialize_queue(recv_1_iq, .{ .color = recv_color });
      @initialize_queue(recv_2_iq, .{ .color = send_recv_color });
    }

    // Export symbol pointing to y so it is host-readable
    @export_symbol(NZ_ptr, "NZ");
    @export_symbol(A_ptr, "A");
    @export_symbol(x_ptr, "x");
    @export_symbol(b_ptr, "b");
    @export_symbol(y_ptr, "y");

	@export_symbol(start_time_ptr, "start_time");
	@export_symbol(end_time_ptr, "end_time");

    // Export function so it is host-callable by RPC mechanism
    @export_symbol(compute);
}
